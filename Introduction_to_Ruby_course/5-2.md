Introduction

In the video, we're going to be looking at how to define our own methods.I've created a file here called, methods.rb andit contains lots of examples of methods in Ruby.In the first example, here, you can see thatthe def keyword is used to define the method.This is then followed by the name of the method,which in this case is called Hello.The code for the method comes next before finishing with the end key word here.Now the last line in any method in Ruby, is it's return value,which is the value that will be returned by the method when it's called.So this method will simply return this last line here, that is the string Hello.Let's take a look at this in IRB.
Looking at methods.rb in IRB

To do this, we need to go into the terminal, start up IRB, andthen we need to require that file that we were just looking at called methods.rb.To do this, you need to make sure that when you launched IRB,you were in the same directory that the file was saved in.Now, I saved it in my home folder, which I was already in.To require the file, we just type in, requirefollowed by a space, and then we open quote marks.Now, because it's in the same directory, we entered ./ andthen the name of the file, which was methods.rb.And then we close the quote marks.Now, this is very similar to the way that we require the Sinatra gem inour other programs.Now, when I press enter I see the result is true.And this will mean that I now have access to all of the code inside that file soI can use those methods.Now to call a method, I simply enter its name.So I just type in hello.Press enter, andI can see that I get the string that was the last line of the method.So, it's return value, andthis is the value being returned by the method when it's called.Now, I can run this method over and over again, just by typing its name.
DRY Principle

So I can write hello again, and I'll still get the same return value.Try it again, we get the same return value.This is one of the advantages of using methods.It means you don't need to write repetitive blocks of code over andover again.Another advantage is that if you want some of the functionality to change,then you only need to update the method in one place.This is known as the DRY Principle, which stands for Don't Repeat Yourself,and it's a very important principle to keep in mind when programming.Going back to the methods.rb file, and our next method,we can see that methods can be made more effective by including parameters.These are values that are provided for the method to use, as we can see here.
Method say_hello_to

This method is called say_hello_to, and then it includes a parameter.And it comes after inside the parentheses, and it's called name.I can then refer to this parameter,as if it was a variable inside the body of the function.So you can see inside this string of your string interpolation to refer to name,and this will be entered when the method is called as an argument here.Now the parentheses are actually optional, but it's always a good idea to use them.Because it makes it clearer that this is a parameter that's being entered here.
Method say_hello_to in IRB

Let's go ahead and look at this in action by going back to IRB.If I enter say_hello to andthen open it with parenthesis andmy argument will be Ruby.Now what this will do is it will set the name value to Ruby when I press enter.We can see the return value is the string Hello Ruby.Now the good thing about this is I can change that value as I use.So I can enter say_hello_to, and this time, actually,this time I won't use parenthesis.I'll just put a space, and I'll put my name instead.Say hello to Darren, and we can press enter.And, this actually looks quite nice when you don't use the parenthesis,because it almost looks like an English sentence.Say hello to Darren.That's partly because of the way I've chosen to name the method.So, it reads a lot better when it includes the argument there.We can also provide a default argument fora parameter by putting it equal to the default value in the method definition.
Default Arguments

So if I go back to my methods.rb file,we can see I've redefined the say_hello_to method here.And instead of just putting a parameter of name,I've actually placed it equal to Ruby.And this will set it as a default argument.So if I call the method without any arguments,it'll be automatically set to Ruby.If I go back to IRB, we can see how that works.So I can just say_hello_to, andI'm going to press enter now with no argument whatsoever, andwe can see that Ruby is still used as the name.That's because it was set as the default value.Or I can still enter a different value.This time, say_hello_to "Daz".And we can see that overrides the default value and is used instead.We can go ahead and add more and more parameters andgive some of them default arguments.One thing to keep in mind,it's important that anything that has default argument needs to come first.As we can see here, in our next method definition.
Method say_hi_to

The is called, say_hi_to.We can see we've got two parameters, name and job.The job has a default value.Any parameter that does nothave a default value comes first as you can see with name.That will have to be entered by the person calling the method,whereas job will be given the default value of programminglanguage if another value is not entered as an argument.So, let's go back to IRB and test out the say_hi_to method instead.
Method say_hi_to in IRB

I enter say_hi_to, and just enter one argument of "Ruby".This will be set as the name and the job will stay as programming language.I press enter.We can see we get the string, Hi Ruby!Your job as a programming language sounds fun.But if I enter and want to change the job,I can write say_hi_to and of 'Daz".And the second parameter goes after a comma.This will be Teacher, and when I press enter,we can see that now it says, Hi, Daz!Your job as a Teacher sounds fun.So what we could keep in mind there is we can use as many parameters as we like,but anything that does not have a default value will have to come first, andwe can put default values at the end.One of the problems with this approach, though, is as the number of argumentsincreases, it can be difficult to remember the order that they appear in.So in the last example, someone might get the name andjob mixed up making the output sound strange.So when we were calling that last method, if we'd put the name andjob the wrong way around, it might have said hi teacher,your job as a Daz sounds fun, which doesn't really make any sense.
Keyword Arguments

One way to get round this, is to use what are called keyword arguments insteadof just using normal default parameters.These acts by using a hash like syntax for the parameters asdemonstrated in my next method which is defined here.Now this is called greet.And you can see the keyword arguments.Here we have one called name, and it's given a default value of Ruby,with one called greeting, which has a default value of Hello, andwe have another one called job, which has a default value of programming language.Now, you can see it has a very much hash-like syntax here,it looks just like a hash.And if I go and test the sounds,we can see that it actually, because it's got some default values.All we need to do is type greet.We get our standard output here of, hello, Ruby,your job as a programming language sounds fun.But I can actually change some of those default valuesin the keyword arguments by just saying, greet.Now what I have to do now is enter them.Again, a bit like a hash.Say, name is Sherlock.And job is Detective.And if I press Enter, we can see the greeting is still set to Hello,that was the default value, because it wasn't mentioned when I called the method.But the other values have changed Sherlock and Detective.Now one of the nice things about using keyword arguments is that you don'tneed to put them in the same order that they're listed in the method definition.And you don't even have to use them all as we just saw.So we could write greet.And let's say I want to set the job as doctor, it doesn't matterthat job is actually the last, listed keyword arguments in the method,I can still put it first when I call the method.So I can write job as Doctor andthen I can enter name is John andlet's have a go at changingthe greeting to Good Day.And there in the complete reverse order than they were listed in.But if I press Enter, we can see it copes perfectly well with that, andsays, Good Day John, Your job as a Doctor sounds fun.Now this type of method is perfect.First, you need to use lists of options.So when you've got lots of different options that get entered into the method.And it's often used for settings and things like that.And you can see this style or method often used in the methodsthat are used in the Ruby on Rails framework as it uses a lot of options andsettings when methods are called.And, so you don't need to remember all of the different options,all you need to remember are the action options that you want to use, andthen you just enter them in any order you like.We can also create methods with an unspecified number of arguments,now this is done by placing an asterisk symbolin front of the last parameter in the method definition.
Method group_greeting

And we can see that in the next method here, which is called group_greeting.And you can see the parameter there.And it starts with the asterisks symbol.Now, any number of arguments can then be used.And they will be stored an array that will have the same name as the parameter.So, in this case, every argument that it enteredwill be stored inside an array called names.And what we can do is you can see inside the method, is we can then iterate overthe array using the each method just to display a message thatuses puts to output and say Hello to each name in the array.And this is useful if we don't knowhow many arguments we're going to have in the first place.Let's have a go at running this one inside IRB,so if we say this was called group_greeting andyou can see I'm going to use Bart,Lisa, and Maggie.And this will create an array of values of those strings.The array will be called names andit will have three values containing those strings.If I press Enter we can see that the method iterates over that array andsays Hello to each name in turn.We can actually see the return value of the method is actuallythe original array that we can see there.And just to show that we don't need three values we can have any number of values,let's try running that method again.So we type group_greeting.And this time we'll just have two arguments.We'll have Homer and Marge.And once I press Enter, we can see it just iterates over the two values.So, you can see this is a very useful technique if you don't actually know howmany arguments will be used when the method is called.
Block as a Parameter

It's also possible to add a block as a parameter to a methodby placing an ampersand symbol before its name.The block can then be accessed in the method definition,by merely referring to it.And this is useful if you want to run some specific code when a method is called.And we can see here there's an example of a method that I've called repeat.And this takes a parameter called number, which is default volume of two.We can see the block is there and it's quite common just to call it block.You don't need to.The key thing is the ampersand in front of itwhich tells Ruby that you're using the block.
Yield Keyword

And what this will do is we then refer to the yield keywordhere means run the block that was given to it.And what will happen here is the number that's entered,remember it has a default value of two.We then call the times method,to run this block of code that the given number of times.And that given block of code is actually provided as an argument to the method.So let's have a, let's go to IRB, it's probably easier to see this running.If we enter repeatthree, that would be value of number sothe first argument was the value of a number which it defaulted to two.And then the block of code goes here inside curved braces, andputs "Ruby" in my block of code.And the yield command will run this block ofcode this number of times that's how that method works,so when the yield command gets called, this block of code is run andit uses the times method to do it so many times sowe can see when I press enter we get ruby, ruby, ruby.That means that's because the yield command was run three times.Now that could be any block of code that becomes the argument to that method.So, this makes the methods much more flexible,that different pieces of code can be used in the same method.We can make the block of code optional.And we do this by using a handy method block given.And this allows to check if a block was actually provided as an argument.
Method Roll

And we can see this in the next method I've defined here called roll.Now, this is used to demonstrate the rolling of a dice.And it takes the number of sides as an argument,it defaults to six, and it accepts a block as well.But as we can see here,we have to check to see if a block is given when the method is called.And we do it, we use an if statement here to check whether the block was given ornot, and to do two different things depending on whether it is or not.Now first of all, look.If it isn't given, we go to the else clause, andall we do is return a random number from one to the number of sides.If the block is given,then we actually use yield to call that piece of code with an argument.You can add arguments to the yield command.So, this block will take an argument that will be a random numberfrom one up to the number of sides of the dice.
Method Roll in IRB

Let's have a go running this in IRB and we can see how it works.It's quite a flexible method, this.And we can see it running lots of different ways.So the default value was six.This is used just to mimic a six sided dice.So, if I just enter roll, we don't need any parameters of.It'll simply return a random number between one and six.We can see if I keep doing it, hopefully it's random.Yeah, there we go.We get different values being returned.Now, if I wanted to mimic a 20 sided dice, then I'd have to provide an argument.So, I could say, roll and provide the argument of 20.And if I press enter now,we should see we're now getting random numbers between 1 and 20.Now, say that what I wanted to do was roll the dice, butthen I wanted to square the results of rolling the dice.Then, I could use a block to say that I actually want to square the numberthat's returned by the dice.And I do this by providing a block so,instead I'm going to stick with the default value, six.So I'm not going to provide an argument in parenthesis.All I'm going to do is provide a block of code inside curly braces.Now remember, there was a value that was entered,it took a parameter itself, the block of code.So yield enters the random number we've entered into this block of code.And we need to use the straight pipe symbols that you see here.And we need to give that a name.We'll call it the result.I'll put that inside straight pipes there.What we want to do with the results is we want to square it.If you remember our little numbers, the double asterisk symbol.It works to use index notation.That we'll do to the power of two, which of course, squares the number.Alternatively, we could have written the result multiplied by a result andwhat will happen now when I press enter is it will choose a random numberbetween one and six.That's because it will default to six because I didn't provide an argument forthe number of sides and then it will feed that random number into thisblock of code, and that random number will be storedas a temporary variable called results, and it will square that value.We should see now values, just square numbers from 1 to 36.So if I press enter, yes, we can see that.It must have chosen a random number of five and returned 25.Try again.And that's two squared, obviously.One squared.Three squared, and we've got four squared.Five squared again.Six squared.Keep going and it's running that block of code and as you can seehere using blocks as parameters can make methods extremely flexible and powerful.That's all for now about methods and their parameters.
Coming Up in the Next Lesson

And, in the next video, we're going to be refactoring the play your cards rightgame, using methods to tidy up the code and make it easy to follow.See you then.