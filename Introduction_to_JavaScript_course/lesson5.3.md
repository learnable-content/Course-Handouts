Scope in JavaScript

I've mentioned the term Scope a couple of times in this course andI haven't really gone into details about defining it but I'd like to show youmore about how Scope work in JavaScript and why you need to keep it in mind.
Functions with Var Statements

Now, you might have noticed when we've been making functions,we've been creating variables inside those functions to declare local variables suchas counters or things that'll be in the return value.Let's go back to one of the examples that we used in the last set of exercises.When we created the function greeter we passed it a string and an array.And outside of greeter, we created variables forword which is going to be the word that we would greet with andanimals which was the array of animals that we were going to greet.But inside of greeter, we created another variable called counter, andcounter was used exclusively inside of the function greeter.So inside of the function greeter, we could do something likeconsole.log(counter).And if we were to Clear and Run, after greeter has used the variable counterto go through the loop three times, it would give us a console.log of counter.And we see that the counter out here shows up as 3.But if we were to try to console.log that counter variableoutside of the function greeter, let's Clear and Run again.Now, what we can see is that inside of greeter,the number 3 shows up when we console.log(counter).But outside of greeter, we get a reference error when we try to console.log(counter).Counter does not exist outside the scope of the function greeter.In JavaScript, you create a new scope every time that you create a new function.And scope is defined such that variables created within the scope of a functionusing the var keyword only exist within that function, andcan't be accessed outside of that function.
Var Statements Limit Scope

The reason that,that works is because we're using the var statement to create our variables.The var statement limits the scope of the variable to wherever to it was declared.A variable declared without a var statement is valid in JavaScript butit will be applied to the global scope which means that it will exist outsidethe scope of your script and be available inside of the script as well butthat can cause problems.I'm going to show you how global variables work and then I'm going to tell you neverto use them but you need to understand what happens with global variables.We're going to create a quick function and it's just going to be called example.And it's going to have two variables in it.One, which we're going to use the var keyword for.And we're going to call that variable local.And we're going to set it to a value of"Only available inside example()".And then we're going to create another variable called global.And we're going to set that to "Availableanywhere once example has been executed".Now, outside of our function example, let's try to console.log(local) andif we run, we'll see that we get an error because local is not defined.And if we console.lo(global) and Clear andRun, we get the same error because global just doesn't exist anywhere.Now, let's run our example function andlet's put back our console dot log of local after example has run.If we Clear andRun, we'll see that local still doesn't exist outside of the scope of example.And if we try global and we Clear andRun, we'll see that running example with global definedinside of it without the var key word has created a variable in the globalscope that has the value available anywhere once example has been executed.The problem with that is that we don't know at any point in the programwhether example has been executed.Global could be defined or not defined and we have no way of understand that,we don't have a modular approach to how this function works, if it's plying andcreating global variables.And this is one of the many reasons that coding environments that checkthe validity of your job JavaScript code while you're coding will tellyou that variables created without the var key word should not be used.Variables can be inherited by functions from their parent scope.
Variable Scope is Inherited One Way

And functions inherit all of the variables that existin the scope in which they were created which makes sense, because a functionneeds access to the variables that were available at the time that it was created.And let me show you an example of that.We're going to create a variable, we'll call it phrase andwe're going to assign it the value, "Always available".Next we're going to create a function.And we're going to call it example.And inside of it, we're going to define a local variable called local which we'regoing to set to the value of "Only available inside example()".Now, inside of our function we're going toconsole.log(phrase) and console.log(local) andthen we're going to execute example.Now, if we Clear and Run, we'll see that "Always available" and"Only available inside example()" are both console logged becausephrase existed in the scope where function example was created.And of course, out here if we console.log(phrase) andClear and Run, phrase is available outside of examplebut it doesn't make sense to console.log(local)because local was declared as part of the definition of the function example.So if we Clear and Run that we'll get an error,a ReferenceError because local is not defined outside of this example.Understanding the difference between a local variable anda variable that exists outside of the scope of a functionwill help you avoid undefined variable errors like that.
Declaring Variables First

You might also have noticed that inside of each function andin fact inside each of each program that we've been writing, we've beendeclaring all of our variables at the very top of the code that we're writing.JavaScript will hoist the variable declarations to the topof whatever scope that that variable exists in.For that reason, even though JavaScript will let you declare variablesanywhere in the body of your code, it's a very good idea to start each function orscript by declaring any variables you plan to use within that scope.And anytime you come across a variable you need to define,declare it at the top of whatever scope it's going to live in.It will help you keep track of where your variables live.Understanding variable hoisting can help you some of the trickier problems to trackdown in JavaScript.Let me give you an example, we're going to define three different functions andeach one is going to declare their variables in a different way.And I'll show you the effect.Let's create a function, we'll call it predefined.And inside of it we're going to declare a var called before.We're going to set that to five and we're going to declare anothervar which we are going to call after and we're going to set that to ten.And let's console.log(before) plus after.Now let's create a second function.And we're going to call it undefinedAfter.And, we're going to create a block of statements again,and this time again, we're going to start with a var before which is set to five.Then we're going to try to console.log(before + after).And after that we're going to declare var after,which is set to 10.Finally, we're going to create a function calledundeclaredAfter.And here again, we're going to start with a var before = 5.And console.log(before + after).But in this case we're not going to declare any after variable.Let's see what the difference is among these.Let's call predefined.And then we'll call undefinedAfter.And then we'll call undeclaredAfter.And if we run this, we'll see that we get three different results.For the first one, predefined, we get the result 15.And that's because, before and after have both been declared andinitialized to values.And then we're console.logging before + after.In the function undefinedAfter, before has been defined and initialized as five.After has had its declaration hoisted to the top of the function.But it hasn't been defined at the time that console.log is called, sothe value of after is considered undefined.Therefore, before a plus and undefined variable results in a not a number value.However with undeclaredAfter, variable before has been defined and declared butafter has neither been defined nor declared when console.log executes,therefore we actually get an error that says there's a Reference Error,after has not been defined if on the second versionwithout variable hoisting undefinedAfter and undeclaredAfter should both havereturned the same value, but undefinedAfter returns not a number,demonstrating that after had been hoisted so that it could be accessed by thisaddition operator, and return the value not a number.Unlike undeclaredAfter, where after has never been declared, anddoesn't exist, and therefore returns an error.Variable hoisting comes about because when JavaScript processes a script to run it,the compiler does two passes.First it goes through all of the code, defines all of the functions, anddeclares all of the variables.Then on the second pass, it goes through and runs the statements in order.Functions are declared and variables are declared and hoisted to the top of theirscope during the first pass before any execution happens.
The Global Scope

So when considering what Scope a variable is going to live in,JavaScript first looks to see what it's container is.And if it's not contained within a function,that variable is assigned to the Global Scope.All scripts that are being executed at the same timeshare space in a single global object.That global object is called window in browsers, andit's called global on the server, for example, in Node.And because of this,you need to be careful about assigning variables to this global scope.And I can demonstrate this in my browser based examples using JS pin.I'm going to create a variable and I'm going to call it count andI'm going to set it to 5.And I'm going to console.log(count).And if I run this of course I get the value 5.But I can also console.log(window.count).Because here in the browser, window is the name of the global object.And if I clear and run again, you'll see that by defining a variable calledcount at the very top of the scope of my script,I've actually created a count property on the global window object of the browser,and it contains the same value that I've assigned to the variable count.Similarly, I can modify window.count and set it to 10.And, if I console.log(count), after doing that,and clear and run again you'll see that by setting window.count to 10,I've also set the variable in my script count to 10.Every script that runs simultaneously in your browseris going to have access to the window object, just like every script that runssimultaneously on your server is going to have access to the global object.
What's Wrong with Global Scope?

So, what's wrong with assigning variables to the global scope?The problem is that different parts of your codemay reuse a common variable name.And no matter how careful you think you're being,this can happen even within the smallest and most ordinary of scripts.Imagine how much more complicated that could beif you're simultaneously running multiple scripts from multiple programmers,all of them loaded on the same page at the same time.We can start by creating a variable, andwe're going to call it count, and we're going to set it to five.And then we might create a function, and call it thousands,and we'll pass it a parameter of price, and we'll put in a block of code,and inside of this function we might set count equal to1,000 times price.And then return(count).Later we might have a four loop and we might set count = 0.Wait until count is less than six.And count ++ iterate.And inside of here we might, I don't know, do something.And I'm just putting in a comment that says do something.Now at some point in our code,who knows maybe up here near where we've defined the function thousands.We might execute thousands, and pass it a value of 50.And after doing all of those things, there could be a bunch of other code,and at some point we might want a console.log(count).And the question is, after doing all of those things, what'sthe value of count and the point is that we don't really have any way of knowing.Depending on what happened in that bunch of other code andwhat order these things were declared in, because we use the same count variableover and over again, all in the same scope,we've lost track of what the value of count actually is going to be.And this gets even worse if we leave off the var keyword on count.Now, no matter how carefully we've managed our scripts,the variable count could exist anywhere in any of the scripts that we're running Andby changing it here, it could change it there.We've lost total control.Basically, you want to be careful not to set variables on the global scope andyou want to pay attention to warnings that tell you not to use global scope.
Ways to Isolate Variable Scope

There are some ways to isolate variable scope andthese are good practices to keep in mind when you're coding.Keep local variables out of the global object by declaring them inside offunctions, wrap all of your code inside of an immediately invoked functionexpression or write your code inside of custom objects that containall of the methods you're going to be using and encapsulate them that way.And I'll give you an example of each of these three ways to encapsulate yourvariable scope.The first way we've been talking about when you declare a function,such as thousands, which operates on price,declare your variables inside of that function using the var keyword.And you can be confident that those variables will only exist within the scopeof that function.A second way is by creating an immediately invoked function expression.So imagine that we have some code and we're going to create a variable calledcount and we're going to make a for loop and inside of that forloop, we're going to set an initial state of count is equal to zero andwe want it to run as long as count is less than ten.And we want to iterate count each time that the loop runs.And inside of here, we want to do something.In order to protect the global scope from all of this code,what we can do is start by creating a function inside of parenthesis andwe're going to declare a function and create a block forthat function to exist in.We're going to copy all of the code of this program here inside ofthat function and we're going to tab in just for formatting.And at the end of that function, we're actually going to execute the function assoon as it's declared and we're going to do to that the same way we executeany function with a set a parentheses and we end with a semicolon.Now this block of code here is protected from the global scope,that variable count only exists inside of this function,which is declared immediately executed and ends right there.That's an immediately invoked function expression andit's a very good way to keep your code safe from the global scope and vice versa.A third way is to start by declaring an object that's going to containall of the code for your application.So for example, you might create a variable called myApp andwe're going to set it to an empty object.Then any time that you want to create a variable foryour code, you could say, myApp.count = tothe string "Hello".length or whatever you like.Now the point is that I've used count here, as part of this function thousands.I've used count here within this immediately evoked function expression forthis for loop.And here, I've used count to represent the length of Hello.But if I console.log(count) and I Clear andRun, you'll see that count is not defined.And that's because all three of these methods protect the global scope from evenhaving access to the variable count,regardless of the fact that I'm using it effectively in all three of these cases.Being a good developer citizen while you're programming in JavaScript,means understanding how you isolate your variables from the global scope, sothat your variables don't leak into other people's programs and vice versa.