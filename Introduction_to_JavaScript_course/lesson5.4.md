Introduction

We've talked about a few different variable types, andone of the things you may not be aware of is that in JavaScripta function can also be treated as a variable type.And this is one of the reasons JavaScript is also considered a functional language.
Functions in the Global Scope

Functions that we declare in programs outside of any other scopelive in the global scope.When you declare a function using the function keyword,you're adding it to the global scope, the same way that you'd be adding a variableto the global scope if you declared it outside of any other containing scope.And I can demonstrate that quickly.We've seen this function that we've declared before.It's our greeter function, that takes a string and an array andcreates a greeting.If we console.logthat function greeter, without using the parenthesis andwe Clear and rerun that, we see that we get the code of our greeter function.Similarly, if we change what we're console.logging here to window.greeter,since we're in a browser context, and we Clear and Run again, we'll see thatwe've declared the function greeter on the global window object here in the browser.And in fact, we can do window.greeter andpass it a string such as hello, andan array, such as "Fred" and "Judy".And, if we Run that,we'll see that we get "Hello Fred", "Hello Judy", which demonstrates thatfunctions declared outside of any other scope live in the global context.
Protecting the Global Scope

But just as with variables, it's important to protect the global scopefrom the functions that you declare that are specific to your program.And, conveniently, all of the tricks that we have used forprotecting the global scope from variables also apply to functions.And I'll give you an example, using the immediately invoked function expression.We'll start again with the same greeter function and to demonstrate that it works,we're going to call greeter, again with the string hello, andthe array Fred, Judy.And if we Run that, of course, we see that we get Hello Fred, Hello Judy.Now, let's wrap all of this inside of an immediately invoked function expression,and to do this we start by creating parentheses, we callfunction and we create a block for the code to live inside of,and we're going to copy and paste all of this code from our program andput it inside this function, and then we're going to add parenthesis at the endof the declaration of this function to invoke the function immediately.Now if we Clear and Run again, we see Hello Fred andHello Judy, her output from the greeter function.But, out here, if we try to console.log,window.greeter, and we Clear andRun again, we'll see that window.greeter has not been defined.And that's because here, inside the context of an immediately invoked functionexpression, we could create a function andexecute it without actually adding anything to the global scope.And this is one of the main reasons why many programmers today writetheir programs inside of immediately invoked function expressions, sothat they can protect the global scope.
Functions Declared in Functions

But functions are also protected from being in the global scopeif they're declared in the context of another function.And, it's interesting to note that a function can declare local functionswithin their own local scope, just the same way that an immediatelyinvoked function expression can declare a function inside of its local scope.And another good reason to do this is if you're creating a functionthat's really only needed within the scope of a particular function.And let me show you an example of that.So imagine if we take our greeter function andwe decide that we want to create a different way of formatting our output.Let's make this a little bit cleaner.Let's add a var called phrase.And instead of console.logging this concatenated string,let's set phrase to equal value of that concatenated string,and then we're going to console.log Phrase.And we're just doing this to clean up our formatting a little bit.So if we Run that, we see we still get Hello Fred and Hello Judy.Now, imagine that instead of just phrase, we want to shout phrase.We want to take whatever string comes in andwe want to set it all to upper case and we want to add an exclamation point.So we could do that here, inside of the greeter function, butit might be more convenient to have a separate function that takes a string andputs it all in upper case, and adds an exclamation point to it, that way wewouldn't be confusing the function that does the formatting of our string,with the function that creates the structure of our string.So, we're going to create another function called "shout" and we're going topass it here inside of our console.log, we want to shout the phrase.Now, if we were to Clear and Run right now since we haven't defined shout,we would get a reference error because shout has not yet been defined.And where were we going to define shout?Well we have an immediately invoked function expression that's wrapping allof our program here.So we want to define shout in the context of that immediately invoked functionexpression.But in addition,shout is a function that is only going to be useful inside of our greeter function.So what we can do is, inside of the function greeter,we can define a function shout.And it'll take a string, andwe'll give it a block of statements to execute,and what we wanted to do is just return str our stringusing the two uppercase method of strings.And then we're going to use the concatenation operator,then concatenate on exclamation mark.Now if we clear and run this, we'll see that our shout functiongets executed properly inside of the context of our greeter function, and we'veprotected everything inside of our program that doesn't have to do with greeting andshouting from having access to that shout function.And I can demonstrate that by trying out here to do a shoutof world,all in lowercase, and if we Clear and Run this, we'll seethat outside of the context of our greeter function, shout doesn't even exist.So not only have we protected the global scope from having access to shout, we'veprotected anything outside of the greeter function from having access to shout.And we can make this shout function just as complex as we want to.For example, we could pull out the punctuation andmake it a separate emphasis parameter that we can pass.And we can make that parameter optional if we want.But that entire function exists only in the context of our greeter function, anddoesn't affect the scope outside of our greeter.
Passing Functions to Functions

Now I mentioned that functions can be treated as values, andthat means that you can actually pass a function to a function.A function can take an anonymous function, which can be declaredright in the arguments that you're passing to that function, andyou don't even need to give it a name.It'll still work.And let me show you an example of how that happens.Going back to our greeter function, we have the version here wherewe've declared a separate phrase, we're defining the value of that phrase, andthen we're console.logging that phrase so we can greet, "Hello Fred and Judy".And if we run that we get "Hello Fred, Hello Judy".But what if we want the flexibility of letting ourselves display thisthe way that we choose at the time that we pass the parameters?Let's create another argument here forthe function greeter and we're going to call that argument display.And, down here,where we're console.logging phrase, we're going to use the function display,whatever that function happens to be, to format our phrase.Now, if we run right now, we're going to get an error because "display" is notdefined as a function yet.But, we can define that function right here when we call the "greeter" function.And what we're going to do here is create an in-line anonymous function andthat's as simple as using the function keyword,establishing the parameter that we want to use,in this case str, and establishing a block of statements.And we're just going to return str in this case.What we've done here is we've defined a function anonymously, without a name.We've said that it takes an argument, which we're calling str, andall that it does is return str.Now if we Clear and Run this, what we see is that this functionhas been put in here inside of greeter as the display function andinvoked on phrase, when we called greeter.And that function can actually do anything that we want and return the value.For example, if we copy and paste this line we could define our anonymous in linefunction to return str with a toUpperCase method anda string that has three exclamation marks at the end of it.And when we Clear and Run, this time when we invoked greeter,we said "Hello Fred" and "Hello Judy", we converted the string to UpperCase andadded three exclamation marks here, in our in line anonymous function.Using inline anonymous functions this way is very common in event driven JavaScript.One common example is known as a callback, in which you pass a functionto a function, and the function that you pass in is something that you want tohave invoked after everything else inside of the function has been executed.Using this approach you can decide which function you want invokedat the time that you make that call andpass it in as a parameter, along with all the other parameters.Now, since I've demonstrated that functions can be treated as values,
Assigning Functions to Variables

I want to show you one more example of a variable type.Because we can actually assign an anonymous function to a variable,just like any other value.This is one of my preferred ways of defining a function.Let me show you how that would work.Going back to our greeter function.So getting back to our greeter function, you remember that we've defined thisgreeter function and we can invoke it using greeter, asking it Hello Fred andJudy, and if we Run it, we get Hello Fred, Hello Judy.But instead of declaring this as a function, let's use the var keyword andwe're going to declare this as a variable called greeter.And let's set it equal to an anonymous inline functionthat does exactly the same thing.So what we've done here is we've taken the name of the function, andmade it the name of a variable.And we've assigned the value of that variable to be a anonymous inline functionthat operates on a string in an array anddoes all of the same things the greeter does.This whole block now becomes a single statement in JavaScript.And what does every JavaScript statement end with?A semi-colon.So now, if we Clear and Run this, we'll see that we still get the value,Hello Fred and Hello Judy.And since both functions andvariables affect the global scope, defining your functions this way can helpremind you to keep the global scope free of both functions and variables.And once you start treating your functions just like other variables in JavaScript,
Treating Functions as Other Variables

you'll start recognizing that you can pass a function to another functionas a variable, instead of declaring it inline, and that makes for cleaner,more modular code.Let's go back to our greeter example and show how formatting our codeusing functions that have been assigned to variables, to format our strings,can make our code more clean.In this case, when we call greeter, we need to pass a greeting, an array, andalso an inline anonymous function, that takes a string and just forregular display, it returns a string.But what if we wanted to make this a little bit cleaner?What if we wanted to take that function, that anonymous inline function that we'vedeclared, and instead define that as another separate variable function?Let's create a var, and we'll call it say.We're going to set that equal to our anonymous inline functionthat we had previously defined inside of the call to greeter.And we can format that just like any other function.And because this is a variable declaration,we need a semicolon at the end of this statement.So now, we've got a function assigned to the variable say,which we can pass in to greeter, and that's much cleaner than we had it before,with the full function defined inline inside of the greeter call.Now if we Clear and Run this, we see that calling say executes this function,which does a return string, and we get the result that we expected.Another advantage of this is we can define another variable, andwe're going to call it shout.And we're going to set that equal to a function of string, andgive it a block of statements to execute and put a semi-colon at the end of it.And in this case, we're going to have it returna string using the toUpperCase method of strings.And we're going to concatenate that with three exclamation marks.Now let's copy our call to greeter, and make another version,and instead of using the say function, let's use the shout function.Now we can Clear and Run, andwhat we see is the first time with greeter calling say, it says Hello Fred,Hello Judy without making any modifications to the strings.And in the second case passing the shout function that we've created,we have the same results but everything's been converted to uppercase andwe've added exclamation marks.You can see how convenient it is to be able to define functions like thiswhich you might be able to use in different contexts.By creating small named functions assigned to variables,you can create code that's very reusable.