Introduction to "This"

We've seen how functions can be used to give a name to a set of statements sothat you can call them independently.And how they can be assigned to variables and protected from the global scope.But, there's another use of functions that I would like to talk to you about.And that brings up the keyword, This, in JavaScript.
Functions to Construct Objects

Functions can also be used to construct objects to take advantageof JavaScript's object oriented capabilities.You can use a function to define the template of an object andthen instantiate instances of that object using the new keyword.And let me show you a quick example of how that would work.We're going to define an object constructor for a new type of object.And we're going to call that type of object an example.And, we're going to set it equal to a function that takes a string as parameter.And inside of this function,the only thing that we're going to do is use the keyword this andsay this object's name property should be set to the value of string.And, of course, we need to add the semicolon at the end of this variabledeclaration because it's a JavaScript statement,just like any other JavaScript statement.So, let's create a new instance of this example.We're going to create a variable, and we're going to call itexampleFred and we're going to set it using the new keyword andthen call the new example function, and pass it the string Fred.Now, if we console.log exampleFred, and we run that,what we see is that exampleFred, this new variable thatwe've just created, is an object and it has one property.And the property is called name and the value of that property is Fred.So, if we were to console.log exampleFred.name andclear and run that, we would see of course that wewould get exampleFred.name is equal to Fred.And if we were to create another instance usingthe same template, let's call this exampleJudy,and we're going to set that to new example andpass in the string Judy, when we go down here andconsole.log exampleJudy.name,as you might expect, if we clear and run,exampleJudy.name gives us the value, Judy.Using this approach, you can create objects that you can instantiate bycalling a function with the new keyword to generate objects constructed out ofproperties based on the parameters you pass to the function.
Adding Methods to Constructors

And objects constructed this way are not limited to properties.You can also create methods that can be executed, since in JavaScript, a method ora function is just a value that can be assigned to a variable.So, you can assign it to a single property of your new object.Let me demonstrate how you might create an object with a method that can beexecuted on it.Starting with the same example that we had before.We created an example variable and assigned it the function constructor fora string, it can be used as a template for objects that have a name property.Let's add a property called this.greet, and we're going to set greet equalto an anonymous in line function, and give it a block of statements to execute.And in this case, we just want the function to return the string Hellowith a space concatenated with this.name, which will be replacedwith the name of the particular instance of this constructed template.And since we're doing an assignment here, we need to add a semicolon to endthis JavaScript statement assigning this function to this.greet.Now, down here we already have instances that we've created of exampleFred andexampleJudy, each one with a different string for the name property.What if we console.log exampleFred.greetwith the parenthesis to execute it.And we run that.We see that we get, Hello Fred.And if we console.log exampleJudy.greet with the parenthesis,and we clear and run that, we can see that each oneperforms the greet method on its own local copy ofthe name property and gives us the proper result.In this way, we can create objects in JavaScript that canhave their own properties and their own methods.And you can instantiate multiple independent instances of each of theseobjects and use them independently of each other.And we've talked a little bit about scope before in the context of the global scope
Private and Public Properties

and functional scope.But in an object oriented context, JavaScript also respects the scope ofvariables that are declared inside of constructor functions.The variables that are declared with var in a constructor are considered private tothe child objects and their own functions.This mean that if you want to create a variable that's going to be uniqueto each child object and not accessible to anything outside of that child object,you can declare it was a var inside of the constructor function for that object.And let me show you how that works.Using the same constructor we created before, imagine that we want this type ofobject to give a special greeting to somebody whose name is Judy, andotherwise, just give an ordinary greeting.So, let's create a variable inside of the constructor, andwe're going to call that variable special.And we're going to set it to the string Judy.Now, every instance of this example object is going to have its own copy ofthe special string.And that special string is always going to be set to Judy for each one.So, let's modify the greet function to give a different greetingto any instance of this object that has the name property set to Judy.So, let's add a conditional here.And in this case, let's do if this.name is the sameas special which is the variable that we've setto the value Judy, then, let's do one thing.Else, let's just do what we were doing before,which in this case was returning hello plus this.name.Now, what do we want to do?If the name property of this instanceof this constructor is equal to the special value,let's just return the string, well, isn't that special.And put a semicolon at the end.Now, down here, we've already created two instances of this example constructor.The first instance is exampleFred, which as the name property set to Fred, andthe second one is exampleJudy, which has the name property set to Judy.Each one of these instances has a copy of the variable special, andthe property name, and the greet method.So, if we console.log exampleFred.greet,it's going to use its own copy of the special variable to compare its owncopy of name with the special variable and determine whether it should say,well, isn't that special, or return, Hello, this.name.Similarly, the example Judy instance will do the same thing.But in Judy's case, the string is actually set to Judy,which is the same as the special variable.So, if we clear and run,what we see is that the exampleFred instance gives us the string, hello Fred.While the exampleJudy instance, gives us the string, well, isn't that special?What's interesting to note here is that the special variable,even though it exists in both exampleFred and exampleJudy, and we can see that fromthe way that it works here, is not accessible outside of those instances.So, for example, if we try to console.logexampleFred.special, and we clear andrun, we'll see that exampleFred.specialis considered undefined, even though,if we console.log exampleFred.name and we clear and run.We see that we can access the Fred property.The name property of these instances was created using this.name,which makes those properties public and accessible.But special,because it was defined as a variable using the var keyword in the constructor foran example, is not accessible outside of the instances of that object.Using this approach, we can see how we can use JavaScript as an object orientatedlanguage to create template constructor functions and instantiate instances ofthose objects, and each of those instances can have public properties, publicmethods, and also private variables that can't be accessed outside of the instance.