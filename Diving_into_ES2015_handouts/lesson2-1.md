Lesson Introduction

The first thing we're going to talk about in this courseis the introduction of a standard way to encapsulate code using modules.Up until the adoption of ES2015,JavaScript did not have any sort of defined module system.Both RequireJS, an AMD style module loading system andCommonJS a synchronous blocking loading system stepped in to tryto solve this problem years ago, and have achieved wide adoption amongst developers.But there was always still contention as to which to use.ES2015 style modules have yet to be implemented in any browser or NodeJS.We're using Babel here to be able to use the new syntax in our code.By default, Babel will transpile your code to use the CommonJS style module syntax.And thus, making it synchronous and blocking.You can change this behavior by defining a different plugin in the babelrc file.But for the purposes of this course, we will be using the default behavior.
Module Exporting

There are essentially two distinct ways to export code from a module andexpose it to the world.The first thing to do is to simply export a variable or function.Querying this module in another file will give you an immutable binding.This differs from CommonJS in that it makes your code more deterministic andcircular dependencies easier to work with.The exported binding will look like an object literal like thisYou can then just refer to the export that you are looking forby the name of the key.This is great.But often times you want to only export one thing from a module andhave that be the default export.This is where, you guessed it, the "default" keyword comes in.Now if you import that you can refer to the name of the function directly andimport it all in one step.
Importing Modules

Importing modules works very much the same way as exporting.Let's refer back to our last example where weexported the 'add' function as the default.In another module, you can import that like this.Now we will have the 'add' function available in our file.It's that easy.You can also use named imports to import multiple exports all at once.If we changed our module back to its original form like thisWe can then import both of these items like so.This named imports syntax where ad andfoo are between curly braces may look a little strange to you.But don't worry we will be covering this in detail in a later lesson.Essentially, what is happening here,is we are saying that we only want to import specific pieces from the module.Here, we are only importing the 'add' function and the 'foo' variable.In addition to these basic statements, we can import andexport in a few different ways as well.There may be times when you want to export a module from another module.In this case, you can do this directly.Pretty nifty?
More Advanced Module Syntax

How about exporting from a module that doesn't have a default?Yeah, we can do that too.Or how about exporting from a module and changing the name?We can also do that.We can use most of this same syntax for importing modules as wellYou can also import the default as well as other exports.Let's say our module looks like this.You can then import both of these in another module just like this.What's that?You want to see more?Okay.How about named imports and exports?Fantastic.We've learned a bunch about how the new module system works in ES2015.Let's move on and learn a little bit about how this helps us to encapsulate code.